<!doctype html>

<html>

<head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
</head>

<body>
    <canvas width="512" height="512"></canvas>
    <script type="module">
        const GRID_SIZE = 32;

        const canvas = document.querySelector("canvas");

        // check WebGPU support
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        // check for compatible hardware
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        // get interface with hardware
        const device = await adapter.requestDevice();

        // configure + link canvas
        const context = canvas.getContext("webgpu");
        const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device: device,
            format: canvasFormat,
        });

        // interface for providing GPU instructions
        const encoder = device.createCommandEncoder();

        // define geometery to render
        const vertices = new Float32Array([
            // X     Y
            -0.8, -0.8,
            0.8, -0.8,    // Triangle 1
            0.8, 0.8,

            -0.8, -0.8,
            0.8, 0.8,    // Triangle 2
            -0.8, 0.8,
        ]);

        // create GPU buffer to store vertices on the GPU side
        const vertexBuffer = device.createBuffer({
            label: "Cell vertices",     // custom label used for debugging
            size: vertices.byteLength,  // Float32Array provides length attribute
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });

        // copy vertex data into GPU buffer
        device.queue.writeBuffer(vertexBuffer, /*bufferOffset=*/ 0, vertices);

        // define layout of the buffer
        const vertexBufferLayout = {
            arrayStride: 8, // each coord contains 2 floats of 32 bit (4 bytes) = 8 bytes per coordinate
            attributes: [{
                format: "float32x2", // 2D coordinates of 32 bit floats
                offset: 0,  // 1st attribute, so data starts at 0. increases if > 1 attribute within buffer
                shaderLocation: 0, // Position, see vertex shader
            }],
        };

        // uniform buffers are constant across all computation each frame; they dont change based on position, etc.
        // buffer is set using javascript before rendering, then is read-only during draw calls
        const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]); // store grid resolution in gpu uniform buffer
        const uniformBuffer = device.createBuffer({
            label: "Grid Uniforms",
            size: uniformArray.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        device.queue.writeBuffer(uniformBuffer, 0, uniformArray); // write to buffer

        // defining WGSL shader
        const cellShaderModule = device.createShaderModule({
            label: "Cell shader",
            // note: shade code below is done in WGSL.
            code: `

                struct VertexInput {
                    @location(0) pos: vec2f,
                    @builtin(instance_index) instance: u32,
                };

                struct VertexOutput {
                    @builtin(position) pos: vec4f,
                    @location(0) cell: vec2f,
                };

                @group(0) @binding(0) var<uniform> grid: vec2f;

                @vertex
                fn vertexMain(input: VertexInput) -> VertexOutput {

                    let i = f32(input.instance);
                    let cell = vec2f(i % grid.x, floor(i / grid.x));
                    let cellOffset = cell / grid * 2;
                    let gridPos = (input.pos + 1) / grid - 1 + cellOffset;
                    
                    
                    var output: VertexOutput;
                    output.pos = vec4f(gridPos, 0, 1);
                    output.cell = cell;
                    return output;
                }

                @fragment
                fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                    let c = input.cell / grid;
                    return vec4f(c, 1-c.x, 1);
                }
                `
        });

        const cellPipeline = device.createRenderPipeline({
            label: "Cell Pipeline",
            layout: "auto",
            vertex: {
                module: cellShaderModule,     // variable holding the shader functions
                entryPoint: "vertexMain",       // name of function
                buffers: [vertexBufferLayout]   // gpu buffer passed as args
            },
            fragment: {
                module: cellShaderModule,
                entryPoint: "fragmentMain",
                targets: [{
                    format: canvasFormat
                }]
            }
        });

        // Bindgroups are used to pass arbitrary data 
        const bindGroup = device.createBindGroup({
            label: "Cell Renderer Bind Group",
            layout: cellPipeline.getBindGroupLayout(0),
            entries: [{
                binding: 0,
                resource: { buffer: uniformBuffer }
            }],
        });

        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: context.getCurrentTexture().createView(),
                loadOp: "clear", // clear texture on start of render pass
                clearValue: { r: 0, g: 0.25, b: 0.5, a: 1 },
                storeOp: "store", // save results of renderpass onto texture 
            }]
        });

        pass.setPipeline(cellPipeline);         // specify render pipeline to use
        pass.setVertexBuffer(0, vertexBuffer);

        pass.setBindGroup(0, bindGroup);        // bind uniform buffer

        pass.draw(vertices.length / 2, GRID_SIZE * GRID_SIZE);         // 6 vertices

        pass.end(); // end of instructions for this render pass

        // const commandBuffer = encoder.finish(); // encodes the renderpass instructions into an object
        // device.queue.submit([commandBuffer]); // submits instructions to the GPU's queue

        device.queue.submit([encoder.finish()]); // submit instruction buffer without storing it instead

    </script>
</body>

</html>